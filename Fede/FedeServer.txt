import mysql.connector
from flask import Flask, request, jsonify
from flask_cors import CORS
import bcrypt  # Libreria per l'hashing sicuro delle password
import random
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

app = Flask(__name__)
CORS(app)

dbConnection = mysql.connector.connect(
    host="localhost",
    user="root",
    password="",
    database="IdP_OAuth2_2FA"
)
dbCursor = dbConnection.cursor()

# Gestione dell'OTP
otp_data = {}

# Funzione per generare OTP
def otp_generator():
    return random.randint(100000, 999999)  # OTP a 6 cifre

# Funzione per inviare OTP via email
def send_otp(email, otp):
    sender_email = "idp.mailservice@gmail.com"  # Sostituisci con il tuo indirizzo email
    receiver_email = email
    password = "kohi grli ueyn rupb"  # Sostituisci con la tua password email

    # Crea il messaggio email
    message = MIMEMultipart()
    message["From"] = sender_email
    message["To"] = receiver_email
    message["Subject"] = "Il tuo codice OTP"

    body = f"Il tuo codice OTP è: {otp}. Questo codice scadrà tra 2 minuti."
    message.attach(MIMEText(body, "plain"))

    # Invia l'email
    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(sender_email, password)
            server.sendmail(sender_email, receiver_email, message.as_string())
    except Exception as e:
        print(f"Errore nell'invio dell'email: {e}")

class AuthenticationServer:
    def __init__(self):
        pass

    def login(self, jsonUsername, jsonPassword):
        query = "SELECT HashedPassword, Email FROM Users WHERE Username = %s;"
        dbCursor.execute(query, (jsonUsername,))
        dbReturn = dbCursor.fetchall()

        if not dbReturn:
            return {"success": False, "message": "Utente non trovato"}
        
        # Verifica la password confrontando l'hash
        hashedPassword = dbReturn[0][0].encode('utf-8')
        email = dbReturn[0][1]

        if bcrypt.checkpw(jsonPassword.encode('utf-8'), hashedPassword):  # Confronto sicuro
            otp = otp_generator()  # Genera OTP
            send_otp(email, otp)  # Invia OTP all'email dell'utente
            otp_data[email] = {
                "otp": otp,
                "timestamp": time.time()  # Memorizza il timestamp per scadenza
            }
            return {"success": True, "message": "OTP inviato", "email": email}  # Includi email nella risposta
        return {"success": False, "message": "Password errata"}




    def verify_otp(self, email, user_otp):
        if not email or not user_otp:
            return {"success": False, "message": "Email o OTP mancanti"}

        if email not in otp_data:
            return {"success": False, "message": "OTP non trovato o già usato"}

        otp_info = otp_data[email]

        if time.time() - otp_info["timestamp"] > 120:
            del otp_data[email]
            return {"success": False, "message": "OTP scaduto"}

        if otp_info["otp"] == int(user_otp):
            del otp_data[email]
            return {"success": True, "message": "Autenticazione completata"}

        return {"success": False, "message": "OTP errato"}





    def register(self, jsonName, jsonSurname, jsonUsername, jsonPassword, jsonEmail):
        # Verifica se lo username esiste già
        query = "SELECT Email FROM Users WHERE Username = %s"
        dbCursor.execute(query, (jsonUsername,))
        if dbCursor.fetchall():
            return {"success": False, "message": "Username già esistente"}

        # Creazione dell'hash della password
        hashedPassword = bcrypt.hashpw(jsonPassword.encode('utf-8'), bcrypt.gensalt())

        # Inserimento nel database
        query = "INSERT INTO Users (Name, Surname, Username, HashedPassword, Email) VALUES (%s, %s, %s, %s, %s)"
        dbCursor.execute(query, (jsonName, jsonSurname, jsonUsername, hashedPassword.decode('utf-8'), jsonEmail))
        dbConnection.commit()

        return {"success": True}

    def forgot_password(self, jsonEmail):
        query = "SELECT Email FROM Users WHERE Email = %s"
        dbCursor.execute(query, (jsonEmail,))
        if not dbCursor.fetchall():
            return {"success": False, "message": "Email non trovata"}
        # Qui puoi implementare la logica per l'invio della mail con il link di reset.
        return {"success": True, "message": "Email di reset inviata"}


@app.route("/login", methods=["POST"])
def login():
    data = request.get_json()
    username = data.get("username")
    password = data.get("password")
    auth_server = AuthenticationServer()
    result = auth_server.login(username, password)
    return jsonify(result)

@app.route("/verify-otp", methods=["POST"])
def verify_otp():
    data = request.get_json()
    print("Dati ricevuti per OTP:", data)  # Debug
    email = data.get("email")
    user_otp = data.get("otp")
    auth_server = AuthenticationServer()
    result = auth_server.verify_otp(email, user_otp)
    print("Risultato verifica OTP:", result)  # Debug
    return jsonify(result)

@app.route("/register", methods=["POST"])
def register():
    data = request.get_json()
    print("Dati ricevuti:", data)  # Debug: verifica i dati inviati dal frontend
    name = data.get("name")
    surname = data.get("surname")
    username = data.get("username")
    password = data.get("password")
    email = data.get("email")
    auth_server = AuthenticationServer()
    result = auth_server.register(name, surname, username, password, email)
    print("Risultato registrazione:", result)  # Debug: verifica il risultato
    return jsonify(result)


@app.route("/forgot-password", methods=["POST"])
def forgot_password():
    data = request.get_json()
    email = data.get("email")
    auth_server = AuthenticationServer()
    result = auth_server.forgot_password(email)
    return jsonify(result)

if __name__ == "__main__":
    app.run(debug=True)